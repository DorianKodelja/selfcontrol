#!/usr/bin/perl
#
# SelfControl -- Stop internet distractions so you can get some work done.
#
use strict;
use warnings;
use YAML ();

#
# Get config from $ENV{HOME} of calling user.  Some trickery
# involved since %ENV is cleared by sudo for security reasons.
# Get from passwd by uid.
#
my $UID = $<;
$UID = $ENV{SUDO_UID} if exists $ENV{SUDO_UID};
my $HOME = (getpwuid($UID))[7];
my $ConfigFile = "$HOME/.selfcontrol";

#
# if root, apply Config and exit.
#
if ($< == 0) {
  check_chain();
  add_chain($ConfigFile);
  add_hosts($ConfigFile);
  exit;
}

#
# not root
#

my @SUDO;
@SUDO = (gksudo => '-D' => 'Self Control');  # XXX annoying if testing.

=for comment - future non-gui interface.

if (-t STDIN) {
  @SUDO = (sudo => '-p' => "Enter your password to perform administrative tasks.\nThe application 'This Program' lets you modify essential parts of your system.\nEnter Password:");
}
else {
  @SUDO = (gksudo => '-D' => 'This Program');
}

=cut

# default config if none exits.
# hope nobody misses example.com for one hour
my $Config = {
  version => 1,
  allow => 1,
  hosts => [[qw<example.com 192.0.32.10>]],
  timeout => 5,
};

$Config = load_config($ConfigFile, $Config);

require SelfControl::UI;
my $UI = SelfControl::UI->new({
  config => $Config,
});
$UI->run();
$Config = $UI->{config};

#
# if 'Start' was clicked, save changes and run self as root
# to apply the blocks and schedule their removal.
#
if ($UI->{started}) {
  save_config($ConfigFile, $Config);
  if (scalar @{$Config->{hosts}}) {
    system(@SUDO, $0);
  }
}

exit;

####################################################################
# Support Routines
####################################################################

#
# Manipulate the ConfigFile.
#

sub load_config {
  my ($ConfigFile, $Config) = @_;
  if ( -f $ConfigFile ) {
    $Config = YAML::LoadFile($ConfigFile);
    if (exists $Config->{version}) {
    }
    else {
      $Config->{timeout} *= 60;  # pre 'version' in hours, convert to minutes.
      $Config->{version} = 1;
    }
  }
  return $Config;
}
sub save_config {
  my ($ConfigFile, $Config) = @_;
  YAML::DumpFile($ConfigFile, $Config);
}

#
# Manipulate firewall.
#

sub check_chain {
  my $out;

  $out = `iptables -S SelfControl`;
  unless ($out =~ m/^-N SelfControl\s*$/m) {
    system("iptables -N SelfControl");
  }

  $out = `iptables -S OUTPUT`;
  unless ($out =~ m/^-A OUTPUT -j SelfControl\s*$/m) {
    system("iptables -A OUTPUT -j SelfControl");
  }
}
sub add_chain {
  my ($ConfigFile) = @_;
  unless (-f $ConfigFile) {
    die "No Config File found: '$ConfigFile'\n";
  }
  my ($Config) = load_config($ConfigFile);

  my $ts = "now + $Config->{timeout} minutes";
  open my $at, '|-', "at '$ts' 2>/dev/null" or die $!;
  for my $hr (@{$Config->{hosts}}) {
    my $h = $hr->[1];
    system("iptables -I SelfControl -d $h -j DROP");
    print $at "iptables -D SelfControl -d $h -j DROP\n";
  }
  close $at;
}
sub add_hosts {
  my ($ConfigFile) = @_;
  unless (-f $ConfigFile) {
    die "No Config File found: '$ConfigFile'\n";
  }
  my ($Config) = load_config($ConfigFile);
  my $ts = "now + $Config->{timeout} minutes";
  my @hn;
  for my $hr (@{$Config->{hosts}}) {
    my $h = $hr->[0];
    next if $h =~ /\.\d{1,3}$/;  # purge any IP only.
    push @hn, $h;
  }
  if (@hn) {
    open my $at, '|-', "at '$ts' 2>/dev/null" or die $!;
    open my $hf, '>>', '/etc/hosts' or die $!;
    print $at "ed /etc/hosts <<_EOF_ 2>/dev/null\n";
    for (@hn) {
      my $esc = $_;
      $esc =~ s/\./\\./g;
      print $hf "127.0.0.2 $_ # SelfControl - DO NOT EDIT!\n";
      print $at "/^127\\.0\\.0\\.2 $esc # SelfControl - DO NOT EDIT!\$/d\n";
    }
    close $hf;
    print $at "wq\n_EOF_\n";
    close $at;
  }
}
