#!/usr/bin/perl
#
# SelfControl -- Stop internet distractions so you can get some work done.
#
use strict;
use warnings;
use YAML ();

#
# Get config from $ENV{HOME} of calling user.  Some trickery
# involved since %ENV is cleared by sudo for security reasons.
# Get from passwd by uid.
#
my $UID = $<;
$UID = $ENV{SUDO_UID} if exists $ENV{SUDO_UID};
my $HOME = (getpwuid($UID))[7];
my $ConfigFile = "$HOME/.selfcontrol";

#
# if root, apply Config and exit.
#
if ($< == 0) {
  check_chain();
  add_chain($ConfigFile);
  add_hosts($ConfigFile);
  exit;
}

#
# not root
#

my @SUDO;
@SUDO = (gksudo => '-D' => 'Self Control');  # XXX annoying if testing.

=for comment - future non-gui interface.

if (-t STDIN) {
  @SUDO = (sudo => '-p' => "Enter your password to perform administrative tasks.\nThe application 'This Program' lets you modify essential parts of your system.\nEnter Password:");
}
else {
  @SUDO = (gksudo => '-D' => 'This Program');
}

=cut

# default config if none exits.
# hope nobody misses example.com for one hour
my $Config = {
  version => 1,
  allow => 1,
  hosts => [[qw<example.com 192.0.32.10>]],
  timeout => 5,
};

#require Glib;
#Glib->import(qw<TRUE FALSE>);
use constant TRUE => 1;
use constant FALSE => 0;

require Gtk2;
Gtk2->init;

require Gtk2::SimpleList;
Gtk2::SimpleList->import;

# $Start set to 1 by clicking 'Start' button, see start().
my $Start = 0;

$Config = load_config($ConfigFile, $Config);
build_ui();
Gtk2->main;

#
# if 'Start' was clicked, save changes and run self as root
# to apply the blocks and schedule their removal.
#
if ($Start) {
  save_config($ConfigFile, $Config);
  if (scalar @{$Config->{hosts}}) {
    system(@SUDO, $0);
  }
}

exit;

####################################################################
# Support Routines
####################################################################

#
# Manipulate the ConfigFile.
#

sub load_config {
  my ($ConfigFile, $Config) = @_;
  if ( -f $ConfigFile ) {
    $Config = YAML::LoadFile($ConfigFile);
    if (exists $Config->{version}) {
    }
    else {
      $Config->{timeout} *= 60;  # pre 'version' in hours, convert to minutes.
      $Config->{version} = 1;
    }
  }
  return $Config;
}
sub save_config {
  my ($ConfigFile, $Config) = @_;
  YAML::DumpFile($ConfigFile, $Config);
}

#
# Manipulate firewall.
#

sub check_chain {
  my $out;

  $out = `iptables -S SelfControl`;
  unless ($out =~ m/^-N SelfControl\s*$/m) {
    system("iptables -N SelfControl");
  }

  $out = `iptables -S OUTPUT`;
  unless ($out =~ m/^-A OUTPUT -j SelfControl\s*$/m) {
    system("iptables -A OUTPUT -j SelfControl");
  }
}
sub add_chain {
  my ($ConfigFile) = @_;
  unless (-f $ConfigFile) {
    die "No Config File found: '$ConfigFile'\n";
  }
  my ($Config) = load_config($ConfigFile);

  my $ts = "now + $Config->{timeout} minutes";
  open my $at, '|-', "at '$ts' 2>/dev/null" or die $!;
  for my $hr (@{$Config->{hosts}}) {
    my $h = $hr->[1];
    system("iptables -I SelfControl -d $h -j DROP");
    print $at "iptables -D SelfControl -d $h -j DROP\n";
  }
  close $at;
}
sub add_hosts {
  my ($ConfigFile) = @_;
  unless (-f $ConfigFile) {
    die "No Config File found: '$ConfigFile'\n";
  }
  my ($Config) = load_config($ConfigFile);
  my $ts = "now + $Config->{timeout} minutes";
  my @hn;
  for my $hr (@{$Config->{hosts}}) {
    my $h = $hr->[0];
    next if $h =~ /\.\d{1,3}$/;  # purge any IP only.
    push @hn, $h;
  }
  if (@hn) {
    open my $at, '|-', "at '$ts' 2>/dev/null" or die $!;
    open my $hf, '>>', '/etc/hosts' or die $!;
    print $at "ed /etc/hosts <<_EOF_ 2>/dev/null\n";
    for (@hn) {
      my $esc = $_;
      $esc =~ s/\./\\./g;
      print $hf "127.0.0.2 $_ # SelfControl - DO NOT EDIT!\n";
      print $at "/^127\\.0\\.0\\.2 $esc # SelfControl - DO NOT EDIT!\$/d\n";
    }
    close $hf;
    print $at "wq\n_EOF_\n";
    close $at;
  }
}

#
# Build the UI.
#

sub build_ui {

# Tooltip
  my $tt = Gtk2::Tooltips->new;

# Window
  my $window = Gtk2::Window->new('toplevel');
  $window->set_title("SelfControl");
  $window->set_border_width(10);

  $window->signal_connect(delete_event => \&delete_event);
  $window->signal_connect(destroy => sub { Gtk2->main_quit; });

# VBox
  my $box = Gtk2::VBox->new(FALSE, 0);

# Frame
  my $frame;
  $frame = Gtk2::Frame->new('Block Method');
  $frame->add($box);

# RadioButton
  my $radio;
  #$radio = Gtk2::RadioButton->new(undef, 'Whitelist');
  #$radio->set_active(TRUE) if !$Config->{allow};
  #$radio->signal_connect(toggled => \&set_allow, 0);
  #$box->pack_start($radio, TRUE, TRUE, 0);
  #my @group = $radio->get_group;

# RadioButton
  #$radio = Gtk2::RadioButton->new_with_label(@group, 'Blacklist');
  $radio = Gtk2::RadioButton->new(undef, 'Blacklist');
  $radio->signal_connect(toggled => \&set_allow, 1);
  $radio->set_active(TRUE) if $Config->{allow};
  $box->pack_start($radio, TRUE, TRUE, 0);

# VBox
  $box = Gtk2::VBox->new(FALSE, 0);
  $box->pack_start($frame, TRUE, TRUE, 0);

# Frame
  $frame = Gtk2::Frame->new('Host List');

# VBox
  my $vbox;
  $vbox = Gtk2::VBox->new(FALSE, 0);
  $frame->add($vbox);

# HBox
  my $hbox;
  $hbox = Gtk2::HBox->new(FALSE, 0);
  $vbox->pack_start($hbox, FALSE, TRUE, 0);

# SimpleList
  my $list = Gtk2::SimpleList->new('Host'=>'text', 'IP'=>'text');
  $tt->set_tip($list, "Select hosts for deletion.");
  $list->set_data_array($Config->{hosts});
  $list->get_selection->set_mode('multiple');

# ScrolledWindow
  my $scroll = Gtk2::ScrolledWindow->new;
  $scroll->set_policy('automatic', 'automatic');
  $scroll->add($list);
  $hbox->pack_start($scroll, TRUE, TRUE, 0);

# Button
  my $button;
  $button = Gtk2::Button->new("Delete");
  $tt->set_tip($button, "Delete selected hosts.");
  $button->signal_connect(clicked => \&del_host, $list);
my $bb = Gtk2::VButtonBox->new;
$bb->set_layout_default('start');
$bb->add($button);
  $hbox->pack_end($bb, FALSE, FALSE, 0);

# HBox
  $hbox = Gtk2::HBox->new(FALSE, 0);
  $vbox->pack_start($hbox, FALSE, TRUE, 0);

  
# Entry
  my $entry = Gtk2::Entry->new;
  $entry->set_width_chars(30);
  $tt->set_tip($entry, "Enter a hostname or IP.");
  $entry->signal_connect(activate => \&add_host, [$list, $entry]);
  $hbox->pack_start($entry, TRUE, TRUE, 0);

# Button
  $button = Gtk2::Button->new("Add");
  $tt->set_tip($button, "Add host to list.");
  $button->signal_connect(clicked => \&add_host, [$list, $entry]);
$bb = Gtk2::HButtonBox->new;
$bb->set_layout_default('end');
$bb->add($button);
  $hbox->pack_start($bb, FALSE, TRUE, 0);

  $box->pack_start($frame, TRUE, TRUE, 0);

# Frame
  $frame = Gtk2::Frame->new('Block Time');
  $box->pack_start($frame, TRUE, TRUE, 0);

{
  my $vbox = Gtk2::VBox->new(0,0);

  my $scale = Gtk2::HScale->new_with_range(5, (24*60), 5);
  $Config->{timeout} = 5 if $Config->{timeout} < 5;
  $scale->set_digits(0);
  $scale->set_draw_value(0);
  my $label = Gtk2::Label->new('');
  $scale->set_value(update_time($label, $Config->{timeout}));

  sub update_time {
    my ($l,$t) = @_;
    $t = int($t/5)*5;
    my ($h,$m) = (int($t/60), $t%60);
    my $text;
    $text .= "$h hour" if $h > 0;
    $text .= "s"       if $h > 1;
    $text .= " $m minute" if $m > 0;
    $text .= "s"          if $m > 1;
    $l->set_text($text);
    return $t;
  }

  $scale->signal_connect(value_changed => sub {
    my ($s) = @_;
    my $t = $s->get_adjustment->value;
    $Config->{timeout} = update_time($label, $t);
    $s->set_value($Config->{timeout});
    }
  );

  $vbox->pack_start($scale, 0,0,0);
  $vbox->pack_start($label, 0,0,0);
  $frame->add($vbox);
}

# Button
  $button = Gtk2::Button->new("Cancel");
  $tt->set_tip($button, "Quit without doing anything.");
  $button->signal_connect(clicked => \&cancel, $window);
$bb = Gtk2::HButtonBox->new;
$bb->set_layout_default('edge');
$bb->add($button);
  $button = Gtk2::Button->new("Start");
  $tt->set_tip($button, "Start SelfControl");
  $button->signal_connect(clicked => \&start, $window);
$bb->add($button);
  $box->pack_start($bb, TRUE, TRUE, 0);

# Show
  $window->add($box);
  $window->show_all;
}
sub set_allow {
  my ($widget, $bw) = @_;
  $Config->{allow} = $bw; 
}
sub start {
  my ($widget, $window) = @_;
  $Start = 1;
  $window->destroy;
}
sub cancel {
  my ($widget, $window) = @_;
  $window->destroy;
}
sub del_host {
  my ($widget, $list) = @_;
  my (@sel) = $list->get_selected_indices;
  for my $s (@sel) {
    splice @{$list->{data}}, $s, 1;
    splice @{$Config->{hosts}}, $s, 1;
  }
}
sub add_host {
  my ($widget, $d) = @_;
  my ($list, $entry) = @{$d};
  return unless length $entry->get_text;
  my (@info) = host2name_ip($entry->get_text);
  return unless @info;
  my @data = sort {$a->[0] cmp $b->[0]} @{$Config->{hosts}}, [@info];
  $Config->{hosts} = [@data];
  $list->set_data_array($Config->{hosts});
  $entry->set_text('');
}
sub host2name_ip {
  use Socket;

  my $host = shift;

  # Get an IP address.
  my $packed = gethostbyname($host);

  # Lookup failed?
  return if not defined $packed; 

  my $ip = inet_ntoa($packed);
  if ( $host eq $ip ) {
  # Was given IP, return reverse lookup or IP as name.
    my $name = gethostbyaddr($packed,AF_INET);
    $name = $ip unless defined $name;
    return ($name, $ip);
  }
  else {
  # Was given hostname, return it.
    return ($host, $ip);
  }
} 
sub delete_event {
  return FALSE;
}
